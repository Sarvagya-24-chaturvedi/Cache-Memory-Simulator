"""
Web backend for Cache Memory Simulator + Verilog Integration
============================================================

Features:
- Users with roles (admin / guest) & HMAC integrity.
- Cache simulator (Software): Single level & Hierarchical (L1/L2).
- Verilog Runner (Hardware): Compiles and runs .v files via Icarus Verilog.
- Activity logging and Binary storage.
- Waveform Download: Serves .vcd files generated by the hardware simulation.
"""

from __future__ import annotations

import base64
import hashlib
import hmac
import json
import math
import os
import random
import subprocess  # Required to run Verilog commands
from collections import OrderedDict, deque, namedtuple
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Tuple, Optional

from flask import (
    Flask,
    jsonify,
    request,
    send_from_directory,
    send_file,  # <--- NEW: Required to serve the VCD file
)

# Try importing binary_store, define mocks if missing
try:
    from binary_store import store_binary, read_binary_file
except ImportError:
    def store_binary(*args, **kwargs): pass
    def read_binary_file(): return "Binary store module missing. Create binary_store.py."


# ---------------------------------------------------------------------------
# Files / constants
# ---------------------------------------------------------------------------

USERS_FILE = "users.json"
USERS_HMAC = "users.hmac"
APP_SECRET_FILE = "app_secret.bin"
ACTIVITY_LOG = "secure_log.txt"  # obfuscated entries (base64 of XOR)

# --- Verilog Configuration ---
VERILOG_SOURCE = "cache_logic.v"
VERILOG_TB = "cache_sim_tb.v"
VERILOG_OUTPUT = "cache_sim_exec"
VCD_FILE = "cache_waveform.vcd" # The file generated by the Verilog Testbench

Access = namedtuple("Access", ["instr", "size", "addr"])


# ---------------------------------------------------------------------------
# Security utilities
# ---------------------------------------------------------------------------

def ensure_app_secret() -> bytes:
    """Create a 32-byte secret on first run and return it."""
    if not os.path.exists(APP_SECRET_FILE):
        with open(APP_SECRET_FILE, "wb") as f:
            f.write(os.urandom(32))
    with open(APP_SECRET_FILE, "rb") as f:
        return f.read()


APP_SECRET = ensure_app_secret()


def compute_hmac(data_bytes: bytes) -> str:
    """HMAC-SHA256 over data_bytes using APP_SECRET."""
    return hmac.new(APP_SECRET, data_bytes, hashlib.sha256).hexdigest()


def xor_bytes(data: bytes, key: bytes) -> bytes:
    """Simple XOR obfuscation (not cryptographically strong, but hides plaintext)."""
    out = bytearray(len(data))
    klen = len(key)
    for i, b in enumerate(data):
        out[i] = b ^ key[i % klen]
    return bytes(out)


def hash_password(password: str, salt: bytes | None = None, iterations: int = 200_000) -> Dict:
    """Return dict with salt, iterations and derived key hex."""
    if salt is None:
        salt = os.urandom(16)
    key = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations)
    return {"salt": salt.hex(), "iterations": iterations, "key": key.hex()}


def verify_password_with_record(password: str, record: Dict) -> bool:
    salt = bytes.fromhex(record["salt"])
    it = int(record["iterations"])
    key = bytes.fromhex(record["key"])
    test = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, it)
    return hmac.compare_digest(test, key)


# ---------------------------------------------------------------------------
# Users.json with HMAC integrity
# ---------------------------------------------------------------------------

def load_users() -> Dict[str, Dict]:
    """Load users.json and verify HMAC. Returns dict username->record or empty dict."""
    if not os.path.exists(USERS_FILE):
        return {}

    with open(USERS_FILE, "rb") as f:
        data = f.read()

    if not os.path.exists(USERS_HMAC):
        # Allow recovery if hmac is missing but json exists (optional, strictly raising error here)
        raise RuntimeError("Users file integrity missing (users.hmac not found).")

    with open(USERS_HMAC, "r", encoding="utf-8") as f:
        expected = f.read().strip()

    actual = compute_hmac(data)
    if not hmac.compare_digest(actual, expected):
        raise RuntimeError("Users file HMAC verification failed. Possible tampering.")

    return json.loads(data.decode("utf-8"))


def save_users(users_dict: Dict[str, Dict]) -> None:
    """Save users.json and write HMAC to users.hmac."""
    data = json.dumps(users_dict, indent=2).encode("utf-8")
    with open(USERS_FILE, "wb") as f:
        f.write(data)
    with open(USERS_HMAC, "w", encoding="utf-8") as f:
        f.write(compute_hmac(data))


def ensure_initial_admin() -> Dict[str, Dict]:
    """
    Ensure there is at least one admin account.
    """
    try:
        users = load_users()
    except RuntimeError as e:
        # On integrity failure, reset or raise. Here we raise to be safe.
        print(f"Warning: {e}. If this is a fresh install, delete users.json.")
        users = {}

    if users:
        return users

    # Create default admin
    default_user = "admin"
    default_pass = "admin"
    users = {default_user: {"role": "admin", **hash_password(default_pass)}}
    save_users(users)
    print("Created default admin account (admin/admin). Change this password ASAP.")
    return users


USERS = ensure_initial_admin()


# ---------------------------------------------------------------------------
# Activity log (obfuscated)
# ---------------------------------------------------------------------------

def log_activity(username: str, sequence_name: str) -> None:
    """Append obfuscated log entry. Each line is base64(xor(plaintext, secret))."""
    try:
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        plaintext = f"User:{username}|Sequence:{sequence_name}|Time:{ts}\n".encode("utf-8")
        ob = xor_bytes(plaintext, APP_SECRET)
        b64 = base64.b64encode(ob).decode("utf-8")
        with open(ACTIVITY_LOG, "a", encoding="utf-8") as f:
            f.write(b64 + "\n")
    except Exception as e:
        print("Activity logging failed:", e)


def read_activity_log_decoded() -> List[str]:
    """Return list of decoded log strings (admin use)."""
    if not os.path.exists(ACTIVITY_LOG):
        return []

    lines: List[str] = []
    with open(ACTIVITY_LOG, "r", encoding="utf-8") as f:
        for raw in f:
            raw = raw.strip()
            if not raw:
                continue
            try:
                ob = base64.b64decode(raw)
                pt = xor_bytes(ob, APP_SECRET)
                lines.append(pt.decode("utf-8"))
            except Exception:
                lines.append("[corrupt entry]")
    return lines


# ---------------------------------------------------------------------------
# Cache core (Software Simulation Logic)
# ---------------------------------------------------------------------------


class CacheBlock:
    def __init__(self, tag=None, valid: bool = False, dirty: bool = False):
        self.tag, self.valid, self.dirty = tag, valid, dirty

    def __repr__(self) -> str:
        return f"[T={self.tag} V={int(self.valid)} D={int(self.dirty)}]"


class CacheSet:
    def __init__(self, ways: int, policy: str):
        self.policy = policy.upper()
        self.ways = ways

        if self.policy == "LRU":
            self.blocks: OrderedDict = OrderedDict()
        elif self.policy == "FIFO":
            self.queue: deque = deque()
            self.map: Dict = {}
        else:
            self.map: Dict = {}

    def lookup(self, tag):
        if self.policy == "LRU":
            blk = self.blocks.get(tag)
            if blk:
                self.blocks.move_to_end(tag)
            return blk
        elif self.policy == "FIFO":
            return self.map.get(tag)
        return self.map.get(tag)

    def insert(self, tag, blk: CacheBlock):
        ev = None
        if self.policy == "LRU":
            if tag in self.blocks:
                self.blocks.pop(tag)
            self.blocks[tag] = blk
            if len(self.blocks) > self.ways:
                _ev_tag, ev = self.blocks.popitem(last=False)
        elif self.policy == "FIFO":
            if tag not in self.map:
                self.queue.append(tag)
                if len(self.queue) > self.ways:
                    ev_tag = self.queue.popleft()
                    ev = self.map.pop(ev_tag)
            self.map[tag] = blk
        else:  # RANDOM
            if tag not in self.map and len(self.map) >= self.ways:
                ev_tag = random.choice(list(self.map.keys()))
                ev = self.map.pop(ev_tag)
            self.map[tag] = blk
        return ev

    def __repr__(self) -> str:
        if self.policy == "LRU":
            return repr(list(self.blocks.values()))
        elif self.policy == "FIFO":
            return repr(list(self.map.values()))
        return repr(list(self.map.values()))


class CacheSimulator:
    def __init__(self, csize: int, bsize: int, assoc: int, policy: str):
        self.cache_size, self.block_size, self.assoc, self.policy = (
            csize,
            bsize,
            assoc,
            policy,
        )
        blocks = csize // bsize if bsize else 1
        self.num_sets = blocks // assoc if assoc else 1
        if self.num_sets == 0:
            self.num_sets = 1

        self.sets: List[CacheSet] = [CacheSet(assoc, policy) for _ in range(self.num_sets)]
        self.accesses = 0
        self.hits = 0
        self.misses = 0

        # truth_table rows: [addr_hex, tag_int, set_int, valid_bit, tag_match_bit, "HIT"/"MISS"]
        self.truth_table: List[List] = []

    def addr_decode(self, addr: int) -> Tuple[int, int]:
        blk_no = addr // self.block_size
        s_idx = blk_no % self.num_sets
        tag = blk_no // self.num_sets
        return s_idx, tag

    def access(self, instr: str, size: int, addr: int, seq_name: str | None = None) -> str:
        self.accesses += 1
        s, tag = self.addr_decode(addr)
        cset = self.sets[s]
        blk = cset.lookup(tag)

        valid = 1 if blk and blk.valid else 0
        tag_match = 1 if blk and blk.tag == tag else 0

        if blk and blk.valid:
            self.hits += 1
            result = "HIT"
        else:
            self.misses += 1
            cset.insert(tag, CacheBlock(tag, True, instr.upper() == "WRITE"))
            result = "MISS"

        # record for visualization
        self.truth_table.append(
            [hex(addr), int(tag), int(s), int(valid), int(tag_match), result]
        )

        # Additionally, write a binary representation for the "sequence" file
        try:
            # 32-bit address
            b_addr = format(addr, "032b")
            b_tag = format(int(tag), "b")
            b_index = format(int(s), "b")
            if self.block_size > 0:
                off_bits = max(self.block_size.bit_length() - 1, 0)
            else:
                off_bits = 0
            offset_mask = (1 << off_bits) - 1 if off_bits > 0 else 0
            b_offset = format(addr & offset_mask, f"0{off_bits}b") if off_bits > 0 else "0"
            b_data = "00000001" if result == "HIT" else "00000000"
            store_binary(b_addr, b_tag, b_index, b_offset, b_data, seq_name=seq_name)
        except Exception:
            pass

        return result

    def stats_text(self) -> str:
        hr = (self.hits / self.accesses * 100) if self.accesses else 0.0
        return (
            f"Accesses: {self.accesses}\n"
            f"Hits: {self.hits}\n"
            f"Misses: {self.misses}\n"
            f"Hit Rate: {hr:.2f}%"
        )

    def dump_sets_text(self) -> str:
        s = ""
        for i, set_ in enumerate(self.sets):
            s += f"Set {i}: {set_}\n"
        return s


# ---------------------------------------------------------------------------
# Hierarchical cache model (L1/L2 + main memory)
# ---------------------------------------------------------------------------


class MainMemory:
    """Simple byte-addressable main memory."""
    def __init__(self, size_bytes: int):
        self.size = size_bytes
        self.data = [0] * size_bytes

    def read_block(self, block_address: int, block_size: int) -> List[int]:
        if block_address < 0 or block_address + block_size > self.size:
            raise ValueError("Memory read out of bounds")
        return self.data[block_address : block_address + block_size]

    def write_block(self, block_address: int, block_data: List[int]) -> None:
        end = block_address + len(block_data)
        if block_address < 0 or end > self.size:
            raise ValueError("Memory write out of bounds")
        self.data[block_address:end] = block_data[:]


@dataclass
class HierCacheLine:
    tag: Optional[int] = None
    valid: bool = False
    dirty: bool = False
    block_address: Optional[int] = None
    data: List[int] = field(default_factory=list)
    last_used: int = 0


class HierCache:
    """Set-associative cache with LRU, Write-back + write-allocate."""
    def __init__(self, name: str, size_bytes: int, block_size: int, associativity: int, lower_level):
        self.name = name
        self.size_bytes = size_bytes
        self.block_size = block_size
        self.associativity = associativity
        self.lower_level = lower_level

        if block_size & (block_size - 1) != 0:
            raise ValueError("block_size must be a power of 2")
        num_lines = size_bytes // block_size
        if num_lines % associativity != 0:
            raise ValueError("size_bytes / block_size must be divisible by associativity")
        self.num_sets = num_lines // associativity
        if self.num_sets & (self.num_sets - 1) != 0:
            raise ValueError("num_sets must be a power of 2")

        self.index_bits = int(math.log2(self.num_sets))
        self.offset_bits = int(math.log2(self.block_size))

        self.sets: List[List[HierCacheLine]] = [
            [HierCacheLine(data=[0] * block_size) for _ in range(associativity)]
            for _ in range(self.num_sets)
        ]
        self.time = 0
        self.hits = 0
        self.misses = 0
        self.write_backs = 0

    def _decode_address(self, address: int):
        block_offset = address & (self.block_size - 1)
        index = (address >> self.offset_bits) & (self.num_sets - 1)
        tag = address >> (self.offset_bits + self.index_bits)
        block_address = address - block_offset
        return tag, index, block_offset, block_address

    def _find_line(self, index: int, tag: int) -> Optional[HierCacheLine]:
        for line in self.sets[index]:
            if line.valid and line.tag == tag:
                return line
        return None

    def _select_victim_line(self, index: int) -> HierCacheLine:
        victim = min(self.sets[index], key=lambda line: line.last_used)
        return victim

    def _evict_if_needed_and_fill(self, index: int, tag: int, block_address: int) -> HierCacheLine:
        victim = self._select_victim_line(index)
        if victim.valid and victim.dirty:
            self.lower_level.write_block(victim.block_address, victim.data)
            self.write_backs += 1
        new_block_data = self.lower_level.read_block(block_address, self.block_size)
        victim.tag = tag
        victim.valid = True
        victim.dirty = False
        victim.block_address = block_address
        victim.data = new_block_data[:]
        victim.last_used = self.time
        return victim

    def read_byte(self, address: int) -> int:
        self.time += 1
        tag, index, block_offset, block_address = self._decode_address(address)
        line = self._find_line(index, tag)
        if line is not None:
            self.hits += 1
            line.last_used = self.time
            return line.data[block_offset]
        self.misses += 1
        line = self._evict_if_needed_and_fill(index, tag, block_address)
        return line.data[block_offset]

    def write_byte(self, address: int, value: int) -> None:
        self.time += 1
        tag, index, block_offset, block_address = self._decode_address(address)
        line = self._find_line(index, tag)
        if line is None:
            self.misses += 1
            line = self._evict_if_needed_and_fill(index, tag, block_address)
        else:
            self.hits += 1
        line.data[block_offset] = value & 0xFF
        line.dirty = True
        line.last_used = self.time

    def read_block(self, block_address: int, block_size: int) -> List[int]:
        return [self.read_byte(block_address + i) for i in range(block_size)]

    def write_block(self, block_address: int, block_data: List[int]) -> None:
        for i, b in enumerate(block_data):
            self.write_byte(block_address + i, b)

    def flush(self) -> None:
        for index in range(self.num_sets):
            for line in self.sets[index]:
                if line.valid and line.dirty:
                    self.lower_level.write_block(line.block_address, line.data)
                    line.dirty = False
                    self.write_backs += 1

    def stats(self) -> Dict:
        total_accesses = self.hits + self.misses
        hit_rate = (self.hits / total_accesses) * 100 if total_accesses > 0 else 0.0
        return {
            "name": self.name,
            "size_bytes": self.size_bytes,
            "block_size": self.block_size,
            "associativity": self.associativity,
            "num_sets": self.num_sets,
            "hits": self.hits,
            "misses": self.misses,
            "total_accesses": total_accesses,
            "hit_rate_percent": hit_rate,
            "write_backs": self.write_backs,
        }

    def __str__(self) -> str:
        s = self.stats()
        return (
            f"{s['name']} Cache:\n"
            f"  Size: {s['size_bytes']} bytes, Block: {s['block_size']} bytes, "
            f"Assoc: {s['associativity']}, Sets: {s['num_sets']}\n"
            f"  Accesses: {s['total_accesses']}, Hits: {s['hits']}, "
            f"Misses: {s['misses']}, Hit rate: {s['hit_rate_percent']:.2f}%\n"
            f"  Write-backs: {s['write_backs']}"
        )


def run_hierarchy_demo() -> Dict:
    MEM_SIZE = 1 * 1024 * 1024
    mem = MainMemory(MEM_SIZE)
    for i in range(MEM_SIZE):
        mem.data[i] = i % 256
    l2 = HierCache("L2", 256 * 1024, 64, 8, mem)
    l1 = HierCache("L1", 32 * 1024, 64, 4, l2)
    random.seed(0)
    for addr in range(0, 64 * 1024, 4):
        _ = l1.read_byte(addr)
    for _ in range(50_000):
        addr = random.randint(0, MEM_SIZE - 1)
        _ = l1.read_byte(addr)
    for _ in range(20_000):
        addr = random.randint(0, MEM_SIZE - 1)
        value = random.randint(0, 255)
        l1.write_byte(addr, value)
    l1.flush()
    l2.flush()
    return {
        "l1_stats": l1.stats(),
        "l2_stats": l2.stats(),
        "l1_text": str(l1),
        "l2_text": str(l2),
    }


def get_logic_diagram_text() -> str:
    return r"""
Two-Level Cache Logic Diagram (Conceptual)
-----------------------------------------

              +---------------------------+
              |           CPU             |
              +-------------+-------------+
                            |
                            |  Address [ Tag | Index | Offset ]
                            v
                    +-------+--------+
                    |      L1        |  (small, fast, 4-way set-associative)
                    |  Cache         |
                    +-------+--------+
                            |
                     HIT?   |   MISS
                    <-------+-------------------------------+
                            |                               |
                            v                               |
                    +-------+--------+                      |
                    |      L2        |  (larger, slower,   |
                    |  Cache         |   8-way set-assoc.) |
                    +-------+--------+                      |
                            |                               |
                     HIT?   |   MISS                        |
                    <-------+---------------------+         |
                            |                     |         |
                            v                     |         |
                   +--------+---------+           |         |
                   |    Main Memory   | <--------+---------+
                   | (DRAM / backing) |
                   +------------------+
"""


# ---------------------------------------------------------------------------
# Session tokens
# ---------------------------------------------------------------------------


def make_token(username: str, role: str) -> str:
    payload = json.dumps({"u": username, "r": role}, separators=(",", ":")).encode("utf-8")
    sig = hmac.new(APP_SECRET, payload, hashlib.sha256).digest()
    token_bytes = base64.urlsafe_b64encode(payload + b"." + sig)
    return token_bytes.decode("ascii")


def parse_token(token: str) -> Tuple[str, str] | None:
    try:
        raw = base64.urlsafe_b64decode(token.encode("ascii"))
        payload, sig = raw.rsplit(b".", 1)
        expected = hmac.new(APP_SECRET, payload, hashlib.sha256).digest()
        if not hmac.compare_digest(expected, sig):
            return None
        data = json.loads(payload.decode("utf-8"))
        return data["u"], data["r"]
    except Exception:
        return None


def require_auth(req) -> Tuple[str, str] | Tuple[None, None]:
    auth = req.headers.get("Authorization", "")
    if not auth.startswith("Bearer "):
        return None, None
    token = auth.split(" ", 1)[1].strip()
    parsed = parse_token(token)
    if not parsed:
        return None, None
    return parsed


# ---------------------------------------------------------------------------
# Flask app & Routes
# ---------------------------------------------------------------------------

app = Flask(
    __name__,
    static_folder="static",
    template_folder="templates",
)


@app.route("/")
def index():
    return send_from_directory("templates", "index.html")


@app.route("/static/<path:path>")
def static_files(path):
    return send_from_directory("static", path)


# --- Auth Endpoints ---

@app.post("/api/login")
def api_login():
    data = request.get_json(force=True, silent=True) or {}
    username = (data.get("username") or "").strip()
    password = data.get("password") or ""
    if not username or username not in USERS:
        return jsonify({"ok": False, "error": "Invalid username or password"}), 400
    rec = USERS[username]
    if not verify_password_with_record(password, rec):
        return jsonify({"ok": False, "error": "Invalid username or password"}), 400
    role = rec.get("role", "guest")
    token = make_token(username, role)
    return jsonify({"ok": True, "token": token, "role": role, "username": username})


@app.post("/api/create-account")
def api_create_account():
    data = request.get_json(force=True, silent=True) or {}
    username = (data.get("username") or "").strip()
    password = data.get("password") or ""
    if not username or not password:
        return jsonify({"ok": False, "error": "Username and password required"}), 400
    if username in USERS:
        return jsonify({"ok": False, "error": "User already exists"}), 400
    if len(password) < 4:
        return jsonify({"ok": False, "error": "Password too short"}), 400

    USERS[username] = {"role": "guest", **hash_password(password)}
    save_users(USERS)
    return jsonify({"ok": True})


@app.get("/api/me")
def api_me():
    u, r = require_auth(request)
    if not u:
        return jsonify({"ok": False}), 401
    return jsonify({"ok": True, "username": u, "role": r})


@app.get("/api/admin/users")
def api_admin_users():
    u, r = require_auth(request)
    if r != "admin":
        return jsonify({"ok": False, "error": "Admin required"}), 403
    users_list = [{"username": k, "role": v.get("role", "guest")} for k, v in USERS.items()]
    return jsonify({"ok": True, "users": users_list})


@app.post("/api/admin/users")
def api_admin_create_user():
    u, r = require_auth(request)
    if r != "admin":
        return jsonify({"ok": False, "error": "Admin required"}), 403
    data = request.get_json(force=True, silent=True) or {}
    username = (data.get("username") or "").strip()
    password = data.get("password") or ""
    role = (data.get("role") or "guest").strip().lower()
    if role not in ("guest", "admin"):
        role = "guest"
    if not username or not password:
        return jsonify({"ok": False, "error": "Username and password required"}), 400
    if username in USERS:
        return jsonify({"ok": False, "error": "User already exists"}), 400
    USERS[username] = {"role": role, **hash_password(password)}
    save_users(USERS)
    return jsonify({"ok": True})


@app.delete("/api/admin/users/<username>")
def api_admin_delete_user(username: str):
    u, r = require_auth(request)
    if r != "admin":
        return jsonify({"ok": False, "error": "Admin required"}), 403
    if username not in USERS:
        return jsonify({"ok": False, "error": "User not found"}), 404
    if username == u:
        return jsonify({"ok": False, "error": "Cannot delete the logged-in admin"}), 400
    USERS.pop(username, None)
    save_users(USERS)
    return jsonify({"ok": True})


# --- Simulation Endpoints ---

@app.post("/api/run_simulation")
def api_run_simulation():
    """
    Run software cache simulation (Single or Hierarchical).
    """
    username, role = require_auth(request)
    if not username:
        return jsonify({"ok": False, "error": "Authentication required"}), 401

    data = request.get_json(force=True, silent=True) or {}
    try:
        cache_size = int(data.get("cache_size"))
        block_size = int(data.get("block_size"))
        assoc = int(data.get("assoc"))
    except Exception:
        return jsonify({"ok": False, "error": "Invalid cache parameters"}), 400

    policy = (data.get("policy") or "LRU").upper()
    if policy not in ("LRU", "FIFO", "RANDOM"):
        policy = "LRU"

    hierarchy = bool(data.get("hierarchy", False))
    sequence_name = (data.get("sequence_name") or "uploaded_sequence").strip()
    sequence_text = data.get("sequence_text") or ""

    lines = []
    for line in sequence_text.splitlines():
        line = (
            line.strip()
            .replace("\ufeff", "")
            .encode("ascii", "ignore")
            .decode("ascii", errors="ignore")
        )
        if not line or line.startswith("#"):
            continue
        parts = line.split()
        if len(parts) != 3:
            continue
        try:
            instr = parts[0]
            size = int(parts[1])
            addr = int(parts[2], 0)
            lines.append(Access(instr, size, addr))
        except Exception:
            continue

    if not lines:
        return jsonify({"ok": False, "error": "Sequence empty or invalid"}), 400

    # Log activity
    try:
        log_activity(username, sequence_name)
    except Exception:
        pass

    # 1. Non-hierarchical (Single Level)
    if not hierarchy:
        sim = CacheSimulator(cache_size, block_size, assoc, policy)
        results = []
        for ac in lines:
            res = sim.access(ac.instr, ac.size, ac.addr, seq_name=sequence_name)
            results.append({"instr": ac.instr, "addr": hex(ac.addr), "result": res})
        return jsonify({
            "ok": True,
            "stats_text": sim.stats_text(),
            "sets_text": sim.dump_sets_text(),
            "results": results,
            "truth_table": sim.truth_table,
        })

    # 2. Hierarchical simulation: L1 -> L2 -> MainMemory
    try:
        mem_size = int(data.get("mem_size", 1 * 1024 * 1024))
        l2_cache_size = int(data.get("l2_cache_size", 256 * 1024))
        l2_block_size = int(data.get("l2_block_size", block_size))
        l2_assoc = int(data.get("l2_assoc", max(1, assoc * 2)))
    except Exception:
        return jsonify({"ok": False, "error": "Invalid hierarchy parameters"}), 400

    try:
        mem = MainMemory(mem_size)
        for i in range(min(mem_size, 65536)):
            mem.data[i] = i % 256

        l2 = HierCache("L2", l2_cache_size, l2_block_size, l2_assoc, mem)
        l1 = HierCache("L1", cache_size, block_size, assoc, l2)
    except Exception as e:
        return jsonify({"ok": False, "error": f"Failed to build hierarchy: {e}"}), 400

    results = []
    for ac in lines:
        before_l1_hits = l1.hits
        before_l2_hits = l2.hits

        # Perform operation per-byte
        if ac.instr.upper() == "READ":
            for i in range(ac.size):
                try:
                    _ = l1.read_byte(ac.addr + i)
                except Exception:
                    break
        else:  # WRITE
            for i in range(ac.size):
                try:
                    l1.write_byte(ac.addr + i, 0)
                except Exception:
                    break

        l1_hit = (l1.hits - before_l1_hits) > 0
        l2_hit = (l2.hits - before_l2_hits) > 0
        
        results.append({
            "instr": ac.instr,
            "addr": hex(ac.addr),
            "l1": "HIT" if l1_hit else "MISS",
            "l2": "HIT" if l2_hit else "MISS",
        })

    try:
        l1.flush()
        l2.flush()
    except Exception:
        pass

    return jsonify({
        "ok": True,
        "results": results,
        "l1_stats": l1.stats(),
        "l2_stats": l2.stats(),
    })


# --- VERILOG & WAVEFORM ROUTES ---

@app.post("/api/run_verilog")
def api_run_verilog():
    """
    Compiles and runs the Verilog files using Icarus Verilog.
    Returns the STDOUT logs from the testbench.
    """
    if not os.path.exists(VERILOG_SOURCE) or not os.path.exists(VERILOG_TB):
        return jsonify({"ok": False, "error": f"Verilog files missing ({VERILOG_SOURCE}, {VERILOG_TB})"}), 404

    try:
        # 1. Compile
        compile_cmd = ["iverilog", "-o", VERILOG_OUTPUT, VERILOG_TB, VERILOG_SOURCE]
        comp_result = subprocess.run(compile_cmd, capture_output=True, text=True)
        
        if comp_result.returncode != 0:
            return jsonify({
                "ok": False, 
                "error": "Compilation Failed", 
                "details": comp_result.stderr
            })

        # 2. Execute
        run_cmd = ["vvp", VERILOG_OUTPUT]
        run_result = subprocess.run(run_cmd, capture_output=True, text=True)

        if run_result.returncode != 0:
            return jsonify({
                "ok": False, 
                "error": "Simulation Runtime Error", 
                "details": run_result.stderr
            })

        # 3. Cleanup Executable (Keep VCD)
        if os.path.exists(VERILOG_OUTPUT):
            os.remove(VERILOG_OUTPUT)

        return jsonify({
            "ok": True,
            "output": run_result.stdout
        })

    except FileNotFoundError:
        return jsonify({"ok": False, "error": "Icarus Verilog (iverilog) is not installed or not in PATH."}), 500
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500


@app.route("/api/download_vcd")
def api_download_vcd():
    """Allows the user to download the generated waveform file."""
    if not os.path.exists(VCD_FILE):
        return jsonify({"ok": False, "error": "No simulation run yet. Run Verilog TB first."}), 404
    return send_file(VCD_FILE, as_attachment=True)


# --- Misc Endpoints ---

@app.get("/api/binary-file")
def api_binary_file():
    username, role = require_auth(request)
    if not username:
        return jsonify({"ok": False, "error": "Authentication required"}), 401
    try:
        content = read_binary_file()
    except Exception as e:
        return jsonify({"ok": False, "error": f"Failed to read binary file: {e}"}), 500
    return jsonify({"ok": True, "content": content})


@app.get("/api/admin/activity_logs")
def api_admin_activity_logs():
    username, role = require_auth(request)
    if role != "admin":
        return jsonify({"ok": False, "error": "Admin required"}), 403
    lines = read_activity_log_decoded()
    return jsonify({"ok": True, "logs": lines})


@app.get("/api/logic_diagram")
def api_logic_diagram():
    username, role = require_auth(request)
    if not username:
        return jsonify({"ok": False, "error": "Authentication required"}), 401
    return jsonify({"ok": True, "diagram": get_logic_diagram_text()})


@app.get("/api/hierarchy_demo")
def api_hierarchy_demo():
    username, role = require_auth(request)
    if not username:
        return jsonify({"ok": False, "error": "Authentication required"}), 401
    try:
        out = run_hierarchy_demo()
    except Exception as e:
        return jsonify({"ok": False, "error": f"Hierarchy demo failed: {e}"}), 500
    return jsonify({"ok": True, **out})


if __name__ == "__main__":
    app.run(debug=True)